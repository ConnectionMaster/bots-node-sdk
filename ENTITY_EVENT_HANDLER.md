# Writing Entity Event Handlers

## Table of contents
- [Introduction](#introduction)
- [Entity Event Handler Structure](#structure)
    - [Using Javascript](#js)
    - [Using Typescript](#ts)
- [Writing Event Handler Functions](#writing)
- [Supported Events](#events)
    - [Entity Level Events](#entityEvents)
    - [Entity-Item Level Events](#itemEvents)
- [Access the Backend Using HTTP REST Calls](#rest)
- [Code Samples](#samples)
    - [How to Conditionally Prompt for an Item](#prompt)
    - [How to Validate an Item](#validate)
    - [How to Send Acknowledgement Messages](#acknowledge)
    - [How to Set or Update Bag Items](#update)
    - [How to Use Custom Events](#custom)
    - [How to Invoke a REST API](#restSample)
    - [How to Send Rich Conversation Messages](#messages)

## Introduction <a name="introduction">

An entity event handler (EEH) works in concert with a `System.ResolveEntities` (RE) or `System.CommonResponse` (CRC) component that is defined in the YAML dialog flow to resolve a composite bag entity. An EEH is deployed in a custom component service, in the same way as a custom component, but does not have its own state in the YAML. The RE or CRC component identifies a series of events which you can write event handlers for in an EEH component. Whenever such an event occurs, the RE or CRC component will check whether an EEH is registered with the composite bag entity, and whether the EEH has a handler defined for this specific event. If this is the case, the RE or CRC component will invoke the event handler method in the EEH.

This event-driven approach makes it much easier for you to execute the right code at the right moment while resolving the composite bag entity. Furthermore, it provides full control over the bot messages that are sent to the user, any "candidate" message generated by CRC or RE can always be replaced by writing a corresponding event handler.

While freemarker expressions can still be used in the various fields of a composite bag item, you can choose to avoid writing any freemarker expressions by including the appropriate handlers in his EEH using Javascript.

Once the composite bag entity is fully resolved a `resolved` event is fired, allowing you to do any backend calls as needed in the EEH. This saves you the work of creating a separate custom component in the YAML to do the backend logic. 

## Entity Event Handler Structure <a name="structure">

### Using Javascript <a name="js">

An entity event handler should export two objects, the `metadata` object provides the name of the component and the event handler type (currently only `ResolveEntities` is supported), and the `handlers` object that contains the various entity-level, item-level and custom event handler functions.

```javascript
module.exports = {
  metadata: {
    name: 'myEntityEventHandler',
    eventHandlerType: 'ResolveEntities'
  },
  handlers:  {
    entity: {
      resolved:async (event, context) => {
        // logic to execute once entity is resolved goes here
      }
      // more entity-level handlers here
    },
    items: {
      someCompositeBagItemName: {
        // item-level handlers here
      }
    },
    custom: {
      // custom handlers here
    }
  }
}
```

The `metadata` and `handlers` members can be defined as a function instead of an object if needed.

### Using TypeScript <a name="ts">

When using typescript, the event handler class should implement the `EntityEventHandler` interface which requires two methods to be present: 
- the `metadata` method that should return an object of type `EntityEventHandlerMetadata`.
- the `handlers` method that should return an object of type `EntityEventHandlers`.

```typescript
import { EntityResolutionContext, EntityEventHandler, EntityEventHandlers, EntityEventHandlerMetadata} from '@oracle/bots-node-sdk/lib';

export class MyEntityEventHandler implements EntityEventHandler {

  public metadata(): EntityEventHandlerMetadata {
    return { 
      name: 'myEntityEventHandler',    
      eventHandlerType: 'ResolveEntities'
      };
  }

  public handlers(): EntityEventHandlers {
    return {
      entity: {
        resolved:async (event, context) => {
          // logic to execute once entity is resolved goes here
        }
        // more entity-level handlers here
      },
      items: {
        someCompositeBagItemName: {
          // item-level handlers here
        }
      },
      custom: {
        // custom handlers here
      }
    };
  }

} 
```

## Writing Event Handler Functions  <a name="writing">

The first argument of each event method is the `event` object. The properties available in this object depend on the type of event.
See the list of supported entity events for information on which properties are available with which event.

The second argument of each event method  is the `context` object. This object references the [EntityResolutionContext](https://oracle.github.io/bots-node-sdk/EntityResolutionContext.html) that provides access to many convenience methods to create your event handler logic.

More information on creating conversation messages from an event handler can be found [here](https://github.com/oracle/bots-node-sdk/blob/master/MESSAGE_MODEL.md).

You can use your favorite http client package to make REST calls, however, the [node fetch](https://www.npmjs.com/package/node-fetch) API is pre-installed with the bots-node-sdk. Use the following statement if you want to make REST calls using node-fetch:

```javascript
const fetch = require("node-fetch");
```

or when using typescript:

```typescript
import * as fetch from 'node-fetch';
```

## Supported Events <a name="events">

### Entity Level Events <a name="entityEvents">
The table below lists all entity level events currently supported:

| Event | Description | Event Properties |
|--|--|--|
| validate | Handler for entity-level validations that include two or more bag item values. Validation errors can be registered by calling `context.addValidationError(itemName,errorMessage)`. If validation should fail, this handler should return false. if validation fails, NONE of the item values provided by the user in the last user message will be updated.<br/><br/>NOTE: This handler is called when at least one bag item value has changed. | <ul><li><b>newValues</b>: JSONObject with key-value pairs where key is the item name and value the new item value.</li><li><b>oldValues</b>: JSONObject with key-value pairs where key is the item name and value the old item value.</li><li><b>currentItem</b>: name of item currently being resolved.</li></ul>
| publishMessage | Generic fallback handler that is called when item-specific prompt or disambiguate handler is not specified. | <ul><li><b>currentItem</b>: name of item currently being resolved.</li><li><b>promptCount</b>: number of times the user is prompted for current item (only set in case of prompt event).</li><li><b>disambiguationValues</b>: list of values that matches the user input (only set in case of disambiguate event).</li></ul>
| maxPromptsReached | Generic fallback handler when item-specific handler for reaching max prompts is not specified. | <ul><li><b>currentItem</b>: name of item currently being resolved.</li><li><b>promptCount</b>: number of times the user is prompted for current item (only set in case of prompt event).</li></ul>
| resolved | Function that gets called when the composite bag entity is resolved. You will typically use this function to call some backend API to complete the transaction which the composite bag entity collected the data for. If the backend API call return some errors, possibly forcing you to re-prompt for some invalid bag items, you can do so by simply clearing those bag items. The RE/CRC component will notice the entity is not fully resolved after all, and will resume prompting for missing bag items. | none
| attachmentReceived| Function that gets called when the user sends an attachment. If the attachment can be mapped to a composite bag item, the validate function of that item will be called first. | <ul><li><b>value</b>: the attachment JSON object with properties type and url.</li></ul>
| locationReceived| Function that gets called when the user sends a location. If the location can be mapped to a composite bag item, the validate function of that item will be called first.	| <ul><li><b>value</b>: the location JSON object with properties latitude and longitude.</li></ul>

### Entity-Item Level Events <a name="itemEvents">
The table below lists all entity-item level events currently supported:

| Event | Description | Event Properties |
|--|--|--|
| shouldPrompt | Function that should return a boolean to indicate whether RE/CRC should prompt the user for a value for this item. This handler can be used to conditionally prompt for an item based on the values of other items in the bag. This handler takes precedence over the "Prompt for Value" field that can be populated in the edit composite bag item screen. If no value is returned, this is considered as a false return value, and the user will not be prompted for the item.	| none
| validate | Handler for item-level validations. Item validation errors can be registered by calling `context.addValidationError(itemName,errorMessage)`. These validations are in addition to the validations specified using freemarker in the edit composite bag item screen. If a freemarker validation has already failed for the item, the validate event handler is not called. If validation should fail, this handler should return false. <br/><br/>NOTE 1: This handler is only called when the item value is set or updated. If the validity also depends on other bag item values, the validation rule should be implemented in the validateEntity handler.<br/><br/>NOTE 2: Both this item-level validation handler and the validateEntity handler must return true for the new item value to be stored on the composite bag entity | <ul><li><b>currentItem</b>: name of item currently being resolved.</li><li><b>oldValue</b>: the old valid value if the bag item (not present when the value is not set).</li><li><b>newValue</b>: the new value entered by the user that must be validated.</li></ul>
| publishPromptMessage | Function that can be used to replace or extend the bot message generated by RE/CRC to prompt for the item. RE/CRC takes the prompt from the prompts registered in the edit composite bag item screen. To use the RE/CRC generated messages, you can call `context.addCandidateMessages()`. | <ul><li><b>promptCount</b>: number of times the user is prompted for current item.</li></ul>
| publishDisambiguateMessage | Function that can be used to replace or extend the bot message generated by RE/CRC to disambiguate the user-supplied item values. RE/CRC takes the prompt from the disambiguation prompt registered in the edit composite bag item screen. To use the RE/CRC generated messages, you can call `context.addCandidateMessages()`. | <ul><li><b>disambiguationValues</b>: list of values that matches the user input.</li></ul>
| maxPromptsReached | Function that gets called when the maximum number of prompts for this item as specified in the composite bag item screen is reached. You can either skip this item by calling `context.skipItem(itemName)` and proceed with the next tem in the bag, or you can abandon entity resolution by transitioning out of the component using `context.cancel()`. | <ul><li><b>promptCount</b>: number of times the user is prompted for current item.</li></ul>	

## Access the Backend Using HTTP REST Calls <a name="rest">

You'll find that there are several Node.js libraries that have been built to make HTTP requests easy, and the list changes frequently. You should review the pros and cons of the currently available libraries and decide which one works best for you. We recommend you use a library that supports promises so you can leverage the async nature of the `invoke` method and use the `await` keyword to write your REST calls in a synchronous way.
An easy choice might be the [node fetch](https://www.npmjs.com/package/node-fetch) API that is pre-installed with the bots-node-sdk. Use the following statement if you want to make REST calls using node-fetch:

```javascript
const fetch = require("node-fetch");
```

or when using typescript:

```typescript
import * as fetch from 'node-fetch';
```

The code to make REST calls with `node fetch` within an event handler looks like this:

```javascript

  // Make a REST GET request
  const response = await fetch('http://some-backend-server-url');
  if (response.status === 200) {        
    const data = await response.json();
    // Do something with the data...
  } 

  // Make a REST POST request
  let payload = ...
  const response = await fetch('http://some-backend-server-url',{ method: 'POST', body: payload});
  if (response.status === 200) {        
    context.reply('Transaction successful');
  } else {
    context.reply('Transaction failed');
  }
}
```

## Code Samples <a name="samples">

The samples below use an `Expense` composite bag entity, which has the following items:

| Name | Type | Entity Name |
|--|--|--|
| Amount | Entity | CURRENCY
| Date | Entity | DATE
| Receipt | Attachment	
| Type | Entity | ExpenseType

### How to Conditionally Prompt for an Item <a name="prompt">
We only want to prompt for a receipt when the expense amount is greater than 25 dollars. This can be achieved by adding the `shouldPrompt` event handler for an item

```javascript
items: {
  Receipt: {
    shouldPrompt:async (event, context) => {
      return context.getItemValue('Amount').amount > 25;
    }
  }
```
  
Note here that the `Amount` item returns a `CURRENCY` JSON object, and `amount` property inside this object holds the amount value.

### How to Validate an Item <a name="validate">
Here is the event handler to enforce the expense amount is at least 5:

```javascript
items: {
  Amount: { 
    validate:async (event, context) => {
      let amount = event.newValue.amount;
      if (amount < 5) {
        context.addValidationError("Amount",`Amounts below 5 ${event.newValue.currency} cannot be expensed. Enter a higher amount or type 'cancel'.`);
      }
    }
  }
```

Note how we obtain the new value from the validation event object. And since the `Amount` item value is a CURRENCY JSON object, we need to obtain the `amount` property from it.  We use the `addValidationError` function to register the error message . We could also have used `conversation.reply()` directly. The difference is that when using `conversation.reply()` further processing in the RE/CRC component is stopped, so other items that just got a value are not validated.

To read the validation error message from the skill resource bundle, instead of hardcoding the text, the translate function can be used:

```javascript
items: {
  Amount: { 
    validate:async (event, context) => {
      let amount = event.newValue.amount;
      if (amount < 5) {
        context.addValidationError('Amount', context.translate('expense.amount.minimum', event.newValue));
      }
    }
  }
```

For this code to work, the YAML must define the resource bundle as a variable named rb, and the resource bundle must contain a key expense.amount.minimum.

### How to send acknowledgement messages for updated items or items resolved out of order <a name="acknowledge">
It is quite common for a user to correct a value he previously entered, or to provide an item value that is needed but was not yet promted for. In such cases it is common practice to  send the user an acknowledgement that the information provided has been understood and processed. We can implement this by first creating two helper functions that use the `getItemsUpdated()` and `getItemsMatchedOutOfOrder()` convenience methods of the entity resolution context:

```javascript
function updatedItemsMessage(context) {
  if (context.getItemsUpdated().length>0) {
    let message = "I have updated"+context.getItemsUpdated().map((item, i) => (i!==0 ? " and the " : " the ")+item.toLowerCase()+" to "+context.getDisplayValue(item));
    context.addMessage(message);
  }
}
 
function outOfOrderItemsMessage(context) {
  if (context.getItemsMatchedOutOfOrder().length>0) {
    let message = "I got"+context.getItemsMatchedOutOfOrder().map((item, i) => (i!==0 ? " and the " : " the ")+item.toLowerCase()+" "+context.getDisplayValue(item));
    context.addMessage(message);
  }
}
```

We then call these functions from the generic `publishMessage` event handler that is called for any message the RE / CRC component wants to publish when no item-specific event handler exists:

```javascript
entity: {
  publishMessage:async (event, context) => {
    updatedItemsMessage(context, conversation);  
    outOfOrderItemsMessage(context, conversation);  
    context.addCandidateMessages();
  }
```

Remember that when you add an item-specific handler to publish a prompt or disambiguation message, you should call the same two functions in that handler if you want to preserve this acknowledgement functionality.

### How to Set or Update Bag Items <a name="update">
Here is a sample of updating the expense date and amount based on the scanned receipt. 

```javascript
items: {
  Receipt: {
    validate:async (event, context) => {
      if (event.newValue.type==='image') {
        if (event.newValue.url==='https://upload.wikimedia.org/wikipedia/commons/0/0b/ReceiptSwiss.jpg') {
          let amount =  {"entityName": "CURRENCY", "amount": 54.5,"currency":"chf","totalCurrency": "CHF 54.50 scanned from receipt"};
          let date =  {"entityName": "DATE", "date": 1185753600000,"originalString": "30 july 2007 scanned from receipt"};
          context.setItemValue("Amount",amount);
          context.setItemValue("Date",date);
          context.addMessage(Receipt scanned, amount set to CHF 54.50 and date set to 30 july 2007);
        }
      } else {
        context.addValidationError("Receipt",Receipt must be an image, cannot be ${event.newValue.type});
      }
    }
```

### How to Use Custom Events <a name="custom">
The use case we implement here is as follows: when the user uploads an expense receipt, the expense date and expense amount are taken from the scanned receipt. If the user then tries to change the date or amount, we tell him the date or amount cannot be changed because they need to match the data on the receipt. We then give the user the option to remove the receipt again so he can change the date again. Here is the sample code to do this, with removeReceipt as custom event that is invoked when the user taps the 'Yes' button.

```javascript
items: {
  Date: {
    validate:async (event, context) => {
      if (context.getItemValue("Receipt")!==undefined && event.oldValue("Date")!==undefined) {
        let MessageModel = context.getMessageModel();
        let yes = MessageModel.postbackActionObject("Yes",undefined,{"event" : {"name":"removeReceipt","properties":{"Date":event.value}}});
        let no = MessageModel.postbackActionObject("No",undefined,{});
        let message = MessageModel.textConversationMessage("You cannot change the date that is extracted from the scanned receipt. Do you want to remove the receipt and change the date?",[yes,no] );
        context.addMessage(new MessageModel(message), true);
        return false;
      }
      return true;
    }
  }
},
custom: {
  removeReceipt:async (event, context) => {
    context.clearItemValue("Receipt");
    if (event.Date) {
      context.setItemValue("Date", event.Date);
      context.addMessage("Receipt removed, date set to "+context.getDisplayValue("Date"));
    }
  }
}
```

### How to Invoke a REST API <a name="restSample">
Calling a REST API from within an event handler is straightforward. Since all event handlers are async, you can use the `await` keyword in combination with an NPM HTTP request module that supports promises, like node-fetch. This allows you to write your asynchronous code in a synchronous matter.

```javascript
entity: {
  resolved:async (event, context) => {
    try {
      let payload = context.getEntity();
      // do some transformations on entity JSON payload if needed...
      const response = await fetch('http://expense-backend-server/expense',{ method: 'POST', body: payload});
      if (response.status === 200) {
          context.addMessage(`Thank you for submitting your ${context.getItemValue('Type')} expense`);
      } 
    } catch (error) {
      context.logger().info("Error invoking API: "+error);
    }
  }
```

### How to Send Rich Conversation Messages <a name="messages">

As you have seen in the previous examples, you can use `context.addMessage(<payload>)` to create a bot message that is sent to the user. 
You can call this function multiple times to send multiple messages. See the section on [Conversation Messaging](https://github.com/oracle/bots-node-sdk/blob/master/MESSAGE_MODEL.md) for code samples on how to create a [text message with buttons actions](https://github.com/oracle/bots-node-sdk/blob/master/MESSAGE_MODEL.md#cardMessage), a [card message](https://github.com/oracle/bots-node-sdk/blob/master/MESSAGE_MODEL.md#cardMessage), and an [attachment message](https://github.com/oracle/bots-node-sdk/blob/master/MESSAGE_MODEL.md#attachmentMessage).


